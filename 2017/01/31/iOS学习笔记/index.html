<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="小知识点,iOS," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一、加载图片的方式：

imageNamed:
可以从项目中直接加载，也可以从Assets.xcassets中加载
self.imageview.image = [UIImage imageNamed:@&amp;quot;图片名&amp;quot;];

imageWithContentsOfFile:
只能从项目中加载
NSString *path = [[NSBundle mainBundle] pathF">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS学习笔记">
<meta property="og:url" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/index.html">
<meta property="og:site_name" content="Timer`s blog">
<meta property="og:description" content="一、加载图片的方式：

imageNamed:
可以从项目中直接加载，也可以从Assets.xcassets中加载
self.imageview.image = [UIImage imageNamed:@&amp;quot;图片名&amp;quot;];

imageWithContentsOfFile:
只能从项目中加载
NSString *path = [[NSBundle mainBundle] pathF">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/pch.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/stretch.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/stretch1.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/stretch2.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/stretch3.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/fit.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/application.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/nav1.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/nav2.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/cell1.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/31.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/32.png">
<meta property="og:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/32_1.png">
<meta property="og:updated_time" content="2017-02-21T13:18:26.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS学习笔记">
<meta name="twitter:description" content="一、加载图片的方式：

imageNamed:
可以从项目中直接加载，也可以从Assets.xcassets中加载
self.imageview.image = [UIImage imageNamed:@&amp;quot;图片名&amp;quot;];

imageWithContentsOfFile:
只能从项目中加载
NSString *path = [[NSBundle mainBundle] pathF">
<meta name="twitter:image" content="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/pch.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '作者'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/"/>





  <title> iOS学习笔记 | Timer`s blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Timer`s blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Timer">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Timer`s blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Timer`s blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                iOS学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-31T13:44:43+08:00">
                2017-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/小知识点/" itemprop="url" rel="index">
                    <span itemprop="name">小知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/小知识点/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/01/31/iOS学习笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/31/iOS学习笔记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、加载图片的方式："><a href="#一、加载图片的方式：" class="headerlink" title="一、加载图片的方式："></a>一、加载图片的方式：</h2><blockquote>
<ol>
<li><p>imageNamed:</p>
<p>可以从项目中直接加载，也可以从Assets.xcassets中加载</p>
<p><code>self.imageview.image = [UIImage imageNamed:@&quot;图片名&quot;];</code></p>
</li>
<li><p>imageWithContentsOfFile:</p>
<p>只能从项目中加载</p>
<p><code>NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;图片名&quot; ofType:@&quot;后缀&quot;];</code></p>
<p><code>self.imageview.image = [UIImage imageWithContentsOfFile:path];</code></p>
</li>
</ol>
</blockquote>
<h2 id="二、pch文件："><a href="#二、pch文件：" class="headerlink" title="二、pch文件："></a>二、pch文件：</h2><blockquote>
<ol>
<li><p>pch文件里的内容可以被项目中的所有文件共有。</p>
</li>
<li><p>注意事项：</p>
<ol>
<li>pch文件使用前需要先编译。</li>
<li>需要做一些判断，例如：判断是否有c文件，如果有，则不导入oc文件及语法。</li>
</ol>
</li>
<li><p>使用步骤：</p>
<p>(1). 在项目中创建pch文件。</p>
<p>(2). 在target的<code>Apple LLVM-Language</code>中设置Precompile Prefix Header为Yes。</p>
<p>(3). 在target的<code>Apple LLVM-Language</code>中配置相应的pch文件地址。</p>
<p><img src="/2017/01/31/iOS学习笔记/pch.png" alt=""></p>
</li>
<li><p>作用：</p>
<ol>
<li>存放公用的宏。</li>
<li>存放公用的头文件。</li>
<li>自定义Log输出日志。</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="三、info-plist文件："><a href="#三、info-plist文件：" class="headerlink" title="三、info.plist文件："></a>三、info.plist文件：</h2><blockquote>
<ul>
<li><p>从info.plist文件获取应用版本的方式一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *path = [[NSBundle mainBundle] pathForResource:@&quot;Info.plist&quot; ofType:nil];</div><div class="line">NSDictionary *dic = [NSDictionary dictionaryWithContentsOfFile:path];</div><div class="line">NSString *version = dic[@&quot;CFBundleShortVersionString&quot;];</div></pre></td></tr></table></figure>
</li>
<li><p>从info.plist文件获取应用版本的方式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *version = [NSBundle mainBundle].infoDictionary[@&quot;CFBundleShortVersionString&quot;];</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="四、从代码加载指定的storyboard文件："><a href="#四、从代码加载指定的storyboard文件：" class="headerlink" title="四、从代码加载指定的storyboard文件："></a>四、从代码加载指定的storyboard文件：</h2><blockquote>
<ul>
<li>在AppDelegate.m文件的(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:方法中(注意：取消Targets-&gt;Deployment Info中所指定的storyboard文件)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];</div><div class="line">UIViewController *vc = [storyboard instantiateInitialViewController];</div><div class="line">self.window.rootViewController = vc;</div><div class="line">[self.window makeKeyAndVisible];</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="五、ViewController中loadView方法："><a href="#五、ViewController中loadView方法：" class="headerlink" title="五、ViewController中loadView方法："></a>五、ViewController中loadView方法：</h2><blockquote>
<ul>
<li>作用：加载控制器的View。</li>
<li>调用时间：当控制器的view第一次使用的时候就会调用。</li>
<li>具体使用：<ul>
<li>不会再调用[supper loadView]</li>
<li>只要想自定义控制器的view就调用这个方法(如下代码，其中MyView为自定义的view)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">MyView *myview = [[MyView alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">self.view = myview;</div><div class="line">self.view.backgroundColor = [UIColor redColor];</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="六、背景图片的拉伸："><a href="#六、背景图片的拉伸：" class="headerlink" title="六、背景图片的拉伸："></a>六、背景图片的拉伸：</h2><blockquote>
<p>控件背景在拉伸的情况下可能会出现失真的效果(锯齿)，如下：</p>
<p><img src="/2017/01/31/iOS学习笔记/stretch.png" width="300" height="300/"></p>
<p>可以用代码进行处理</p>
<p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; UIImage *image = [UIImage imageNamed:@&quot;lumaqq&quot;];</div><div class="line">&gt; CGFloat width = image.size.width;</div><div class="line">&gt; CGFloat height = image.size.height;</div><div class="line">&gt; //UIImage * resizeImage = [image resizableImageWithCapInsets:UIEdgeInsetsMake(height/2, width/2, height/2-1, width/2-1)];</div><div class="line">&gt; UIImage *resizeImage = [image resizableImageWithCapInsets:UIEdgeInsetsMake(height/2, 5, height/2-1, width/2-1) resizingMode:UIImageResizingModeStretch];</div><div class="line">&gt; [self.mButton setBackgroundImage:resizeImage forState:UIControlStateNormal];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>其中第5行代码的上、右、下、左分别代表被保护不被拉伸的区域，具体如下：</p>
<p><img src="/2017/01/31/iOS学习笔记/stretch1.png" width="300" height="300/"></p>
<p>进行代码拉伸后的效果如下：</p>
<p><img src="/2017/01/31/iOS学习笔记/stretch2.png" width="300" height="300/"></p>
<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; UIImage *resizeImage = [image stretchableImageWithLeftCapWidth:width/2 topCapHeight:height/2];</div><div class="line">&gt; [self.mButton setBackgroundImage:resizeImage forState:UIControlStateNormal];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>这种方式只需要提供左边和上边的被保护区域，然后就可以计算出另两个被保护区域：</p>
<ul>
<li>右边被保护的区域 = 图片的宽度 - 左边的被保护区域 - 1</li>
<li>下边被保护的区域 = 图片的高度 - 上边的被保护区域 - 1</li>
</ul>
<p>这样主可以在中心形成一个1x1的拉伸区域。</p>
<p>方式三：</p>
<p>直接选择图片，然后在右边的Slicing中选择拉伸模式即可自动进行拉伸(也可自行调整相应的保护值)，如下图：</p>
<p><img src="/2017/01/31/iOS学习笔记/stretch3.png" width="700" height="300/"></p>
</blockquote>
<h2 id="七、KVC：key-value-coding-键值编码"><a href="#七、KVC：key-value-coding-键值编码" class="headerlink" title="七、KVC：key value coding(键值编码)"></a>七、KVC：key value coding(键值编码)</h2><blockquote>
<ol>
<li><p>应用场景：简单的字典转模型。—&gt;框架：MJExtension</p>
</li>
<li><p>设置值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    [person setValue:@&quot;旺财&quot; forKeyPath:@&quot;dog.name&quot;];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>取值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    [person valueForKeyPath:@&quot;name&quot;]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>字典转模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    [person setValuesForKeysWithDictionary:dictionary];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>模型转字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    NSDictionary *dict = [person dictionaryWithValuesForKeys:@[@&quot;name&quot;, @&quot;money&quot;]];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>取出数组中所有模型的某个属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;    NSArray *allPersons = @[person1, person2, person3];</div><div class="line">&gt;    NSArray *allPersonName = [allPersons valueForKeyPath:@&quot;name&quot;];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h2 id="八、KVO：key-value-observing-键值监听"><a href="#八、KVO：key-value-observing-键值监听" class="headerlink" title="八、KVO：key value observing(键值监听)"></a>八、KVO：key value observing(键值监听)</h2><blockquote>
<ol>
<li>当某个对象的属性发生改变的时候用KVO进行监听</li>
<li>使用如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; Person *person = [[Person alloc] init];</div><div class="line">&gt; person.name = @&quot;zhangsam&quot;;</div><div class="line">&gt; /*</div><div class="line">&gt;  作用:给对象绑定一个监听器(观察者)</div><div class="line">&gt;  - Observer 观察者</div><div class="line">&gt;  - KeyPath 要监听的属性</div><div class="line">&gt;  - options 选项(方法方法中拿到属性值)</div><div class="line">&gt;  */</div><div class="line">&gt; [person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil]; </div><div class="line">&gt; person.name = @&quot;lisi&quot;; </div><div class="line">&gt; [person removeObserver:self forKeyPath:@&quot;name&quot;];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>并使用以下方法进行临听：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; /**</div><div class="line">&gt;  *  当监听的属性值发生改变</div><div class="line">&gt;  *</div><div class="line">&gt;  *  @param keyPath 要改变的属性</div><div class="line">&gt;  *  @param object  要改变的属性所属的对象</div><div class="line">&gt;  *  @param change  改变的内容</div><div class="line">&gt;  *  @param context 上下文</div><div class="line">&gt;  */</div><div class="line">&gt; - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="九、适配"><a href="#九、适配" class="headerlink" title="九、适配"></a>九、适配</h2><blockquote>
<ol>
<li><p>系统适配-不同的系统版本适配</p>
</li>
<li><p>屏幕适配-不同的屏幕尺寸适配</p>
<ul>
<li>iPhone的尺寸：3.5､4.0､4.7､5.5</li>
<li>iPad的尺寸：7.9､9.7､12.9</li>
<li>屏幕方向：横屏、竖屏</li>
</ul>
<p><img src="/2017/01/31/iOS学习笔记/fit.png" alt=""></p>
</li>
<li><p>屏幕适配技术</p>
<ol>
<li><p>Autoresizing：解决子控件和父控件之间的相对关系问题</p>
<p>在代码中实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;       myView.autoresizingMask = UIViewAutoresizingFlexibleLeftMargin | UIViewAutoresizingFlexibleTopMargin;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<pre><code>给view设置需要拉伸的方向或者宽高即可。

或者在xcode中对需要拉伸的界面进行如下设置：

&lt;img src=&quot;iOS学习笔记/fit2.png&quot;  width=&quot;300&quot; height=300/&gt;
</code></pre><ol>
<li><p>AutoLayout：</p>
<p>自动布局的核心公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;       obj1.property1 = (obj2.property2 * multiplier) + constant value</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<pre><code>界面实现：

代码实现：很少用，太麻烦。注意使用代码方式需要禁止将Autoresizing转为AutoLayout约束，使用以下代码禁止：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;       myview.translatesAutoresizingMaskIntoConstraints = NO;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</code></pre></blockquote>
<p>&gt;</p>
<blockquote>
<pre><code>VFL实现：Visual Format Language，可视化格式语言:

&lt;img src=&quot;iOS学习笔记/fit3.png&quot;  width=&quot;200&quot; height=100/&gt;
</code></pre><ol>
<li>Masonry框架实现：<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">https://github.com/SnapKit/Masonry</a></li>
</ol>
</blockquote>
<h2 id="十、UITableView"><a href="#十、UITableView" class="headerlink" title="十、UITableView"></a>十、UITableView</h2><blockquote>
<ol>
<li><p>注意点：</p>
<ul>
<li><p>若UITableView的数据不够一页，剩余的界面部分会出现分隔线，解决方法：</p>
<p>(1).将tableview的样式必成Grouped的。</p>
<p>(2).给tableview设置一个footer view。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      [self.tableView setTableFooterView:[[UIView alloc] init]];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>性能优化：</p>
<ul>
<li><p>方式1:</p>
<p>在(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;      static NSString *ID = @&quot;flag&quot;;</div><div class="line">&gt;      UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:ID];</div><div class="line">&gt;          if (cell == nil) &#123;</div><div class="line">&gt;              cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];</div><div class="line">&gt;          &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>方式2:常用于自定义Cell</p>
<p>定义flag：<code>NSString *ID = @&quot;flag&quot;;</code></p>
<p>在viewDidLoad方法中进行注册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:ID];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<pre><code>在(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath方法中：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      UITableViewCell * cell = [tableView dequeueReusableCellWithIdentifier:ID];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</code></pre></blockquote>
<p>&gt;</p>
<blockquote>
<pre><code>​
</code></pre><ol>
<li><p>数据刷新：</p>
<ul>
<li><p>全局刷新：<code>[self.tableview reloadData]</code></p>
</li>
<li><p>局部刷新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;      NSArray *indexPaths = @[</div><div class="line">&gt;                             [NSIndexPath indexPathForRow:0 inSection:0],</div><div class="line">&gt;                             [NSIndexPath indexPathForRow:1 inSection:0]</div><div class="line">&gt;                             ];</div><div class="line">&gt;      // 更新数据</div><div class="line">&gt;      [self.tableView reloadRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationNone];</div><div class="line">&gt;      // 添加数据</div><div class="line">&gt;      [self.tableView insertRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationNone];</div><div class="line">&gt;      // 删除数据</div><div class="line">&gt;      [self.tableView deleteRowsAtIndexPaths:indexPaths withRowAnimation:UITableViewRowAnimationNone];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>左滑添加多个操作按钮：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;    - (NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class="line">&gt;    UITableViewRowAction *deleteAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleDefault title:@&quot;删除&quot; handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123;</div><div class="line">&gt;        [self.datas removeObjectAtIndex:indexPath.row];</div><div class="line">&gt;        [self.tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationAutomatic];</div><div class="line">&gt;     &#125;];</div><div class="line">&gt;     UITableViewRowAction *concernAction = [UITableViewRowAction rowActionWithStyle:UITableViewRowActionStyleNormal title:@&quot;关注&quot; handler:^(UITableViewRowAction * _Nonnull action, NSIndexPath * _Nonnull indexPath) &#123;</div><div class="line">&gt;     	// 设置tableView的编辑模式为NO</div><div class="line">&gt;        self.tableView.editing = NO;</div><div class="line">&gt;      &#125;];</div><div class="line">&gt;      return @[deleteAction, concernAction];</div><div class="line">&gt;    &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>编辑模式：</p>
<p>单选模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    self.tableView.editing = YES;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>   多选模式：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;    self.tableView.editing = YES;</div><div class="line">&gt;    self.tableView.allowsMultipleSelectionDuringEditing = YES;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>   ​</p>
</blockquote>
<h2 id="十一、UIApplication"><a href="#十一、UIApplication" class="headerlink" title="十一、UIApplication"></a>十一、UIApplication</h2><blockquote>
<ol>
<li><p>UIApplication的常用属性：</p>
<ul>
<li>applicationIconBadgeNumber：应用程序图标右上角的红色提醒数字.</li>
<li>networkActivityIndicatorVisible：状态栏的网络加载图标(小菊花)</li>
</ul>
</li>
<li><p>UIApplication的代理事件：</p>
<ul>
<li><p>当应用程序启动完毕时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>当应用程序将要失去焦点时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      (void)applicationWillResignActive:(UIApplication *)application</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>当应用程序进入后台时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      (void)applicationDidEnterBackground:(UIApplication *)application</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>当应用程序进入前台时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      (void)applicationWillEnterForeground:(UIApplication *)application</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>当应用程序获取焦点时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      (void)applicationDidBecomeActive:(UIApplication *)application</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>当应用程序退出时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      (void)applicationWillTerminate:(UIApplication *)application</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>当应用程序收到内存警告时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      (void)applicationDidReceiveMemoryWarning:(UIApplication *)application</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<pre><code>​
</code></pre><ol>
<li><p>应用程序启动流程：</p>
<ul>
<li><p>执行main函数</p>
</li>
<li><p>执行UIApplicationMain，创建UIApplication对象，并设置UIApplication它的对象</p>
</li>
<li><p>开启一个事件循环(主运行循环，死循环：保证应用程序不退出)</p>
</li>
<li><p>加载info.plist(判断info.plist中有没有Main，如果有，加载Main.storyBoard)</p>
</li>
<li><p>应用程序启动完毕(通知代理应用程序启动完毕)</p>
<p><img src="/2017/01/31/iOS学习笔记/application.png" width="500" height="300/"></p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="十二、UIWindow"><a href="#十二、UIWindow" class="headerlink" title="十二、UIWindow"></a>十二、UIWindow</h2><blockquote>
<ol>
<li><p>代码创建Window及ViewController：</p>
<p>在(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;    // 1.创建窗口</div><div class="line">&gt;    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">&gt;    // 2.设置窗口的根控制器</div><div class="line">&gt;    UIViewController *vc = [[UIViewController alloc] init];</div><div class="line">&gt;    vc.view.backgroundColor = [UIColor redColor];</div><div class="line">&gt;    self.window.rootViewController = vc;</div><div class="line">&gt;    // 3.显示窗口</div><div class="line">&gt;    [self.window makeKeyAndVisible];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>通过StoryBoard加载控制器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">&gt;    UIStoryboard *board = [UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:nil];</div><div class="line">&gt;    // 加载初始化的控制器</div><div class="line">&gt;    // UIViewController *vc = [board instantiateInitialViewController];</div><div class="line">&gt;    // 加载指定的控制器</div><div class="line">&gt;    UIViewController *vc = [board instantiateViewControllerWithIdentifier:@&quot;mvc&quot;];</div><div class="line">&gt;    self.window.rootViewController = vc;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>通过xib文件加载控制器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;    self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line">&gt;    // initWithNibName如果指定为nil，首先会加载和控制器名字相同的xib文件；如果没有则去查找和控制器名字相同但是去掉Controller的xib文件。</div><div class="line">&gt;    // 并且可以直接使用：[[UIViewController alloc] init]</div><div class="line">&gt;    UIViewController *vc = [[UIViewController alloc] initWithNibName:@&quot;CPView&quot; bundle:nil];</div><div class="line">&gt;    self.window.rootViewController = vc;</div><div class="line">&gt;    [self.window makeKeyAndVisible];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>   注意，如果UIViewController和xib文件单独创建，需要做以下操作：</p>
<p>   ​        1. 需要设置xib中的UIView的File`s Owner为UIViewController</p>
<p>   ​           2.右击File`s Owner，将其中的view和UIView控件关联</p>
</blockquote>
<h2 id="十三、多控制器：UINavigationController"><a href="#十三、多控制器：UINavigationController" class="headerlink" title="十三、多控制器：UINavigationController"></a>十三、多控制器：UINavigationController</h2><blockquote>
<ol>
<li><p>使用步骤：</p>
<ul>
<li>1.初始化UINavigationController</li>
<li>2.设置UIWindow的rootViewController为UINavigationController</li>
<li>3.根据具体情况，通过push方法添加对应的子控制器</li>
</ul>
</li>
<li><p>UINavigationController常见属性：</p>
<p><img src="/2017/01/31/iOS学习笔记/nav1.png" width="600" height="300/"></p>
</li>
<li><p>UINavigationController标题属性：</p>
<p><img src="/2017/01/31/iOS学习笔记/nav2.png" width="600" height="300/"></p>
</li>
</ol>
</blockquote>
<h2 id="十四、控制器生命周期："><a href="#十四、控制器生命周期：" class="headerlink" title="十四、控制器生命周期："></a>十四、控制器生命周期：</h2><blockquote>
<ol>
<li><p>当控制器加载完毕时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    (void)viewDidLoad</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>当控制器的view即将显示的时候调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    (void)viewWillAppear:(BOOL)animated</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>当控制器的view显示完毕时调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    (void)viewDidAppear:(BOOL)animated</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>当控制器的view将要布局子控件的时候调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    (void)viewWillLayoutSubviews</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>当控制器的view布局子控件完毕的时候调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    (void)viewDidLayoutSubviews</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>当控制器的view即将消失的时候调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    (void)viewWillDisappear:(BOOL)animated</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>当控制器的view消失完毕的时候调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;    (void)viewDidDisappear:(BOOL)animated</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h2 id="十五、OC中BOOL和bool的区别："><a href="#十五、OC中BOOL和bool的区别：" class="headerlink" title="十五、OC中BOOL和bool的区别："></a>十五、OC中BOOL和bool的区别：</h2><blockquote>
<ol>
<li><p>BOOL是一种带符号的字符类型(<code>signed char</code>)的类型定义(<code>typedef</code>)，它使用8位的存储空间。通过#define命令把YES定义为1,NO定义为0。</p>
<p>注意：OC并不会将BOOL作为仅能保存YES或NO值的真正布尔类型来处理。编译器仍将BOOL认作8位二进制数，YES 和 NO 值只是在习惯上的一种理解。<code>例：如果不小心将一个大于1字节的整型值（比如short或int）赋给一个BOOL变量，那么只有低位字节会用作BOOL值。如果该低位字节刚好为0（比如8960，写成十六进制为0x2300），BOOL值将会被认作是0，即NO值。</code></p>
</li>
<li><p>bool只有true和false的区别，即0为false，非0为true。</p>
</li>
</ol>
</blockquote>
<h2 id="十六、initialize和load方法的区别："><a href="#十六、initialize和load方法的区别：" class="headerlink" title="十六、initialize和load方法的区别："></a>十六、initialize和load方法的区别：</h2><blockquote>
<ol>
<li>initialize方法：在 第一次初始化这个类之前 被调用，我们用它来初始化静态变量。先调用类中的，再调用类别中的(类别中如果有重写)；如果该类只是引用，没有调用，则不会执行initialize方法。</li>
<li>load方法：会在加载类的时候就被调用，也就是 ios 应用启动的时候，就会加载所有的类，就会调用每个类的 + load 方法。且在main函数之前，先调用类中的，再调用类别中的(类别中如果有重写)。</li>
</ol>
</blockquote>
<h2 id="十七、instancetype和id的区别："><a href="#十七、instancetype和id的区别：" class="headerlink" title="十七、instancetype和id的区别："></a>十七、instancetype和id的区别：</h2><blockquote>
<ol>
<li>instancetype用来在编译期确定实例的类型,而使用id的话,编译器不检查类型, 运行时检查。</li>
<li>id可以作为方法的参数,但instancetype不可以；instancetype只适用于初始化方法和便利构造器的返回值类型。</li>
</ol>
</blockquote>
<h2 id="十八、OC访问修饰符："><a href="#十八、OC访问修饰符：" class="headerlink" title="十八、OC访问修饰符："></a>十八、OC访问修饰符：</h2><blockquote>
<ol>
<li><p>属性访问符：</p>
<p>@private: 私有 被@private修饰的属性只能在本类的内部访问。只能在本类的方法实现中访问。</p>
<p>@protected: 受保护的(默认) 被@protected修饰的属性只能在本类和本类的子类中访问.。只能在本类和子类的方法实现中访问。</p>
<p>@package: 被@package修饰的属性 可以在当前框架中访问。</p>
<p>@public: 公共的。被@public修饰的属性 可以在任意的地方访问。</p>
</li>
<li><p>说明：</p>
<p>在interface中声明的成员变量默认是protected。</p>
<p>在implementation中声明的成员变量，默认是private（在没被import的情况下，即使加@public仍然无法被他人引用）。</p>
<p>@property  用于生成getter与setter的声明，只能用于interface中。</p>
</li>
</ol>
</blockquote>
<h2 id="十九、OC属性修饰符："><a href="#十九、OC属性修饰符：" class="headerlink" title="十九、OC属性修饰符："></a>十九、OC属性修饰符：</h2><blockquote>
<ol>
<li><p>修饰符分类：</p>
<ul>
<li>自定义getter | setter方法名修饰符 : getter和setter</li>
<li>原子性修饰符:atomic | nonatomic</li>
<li>读写性修饰符：readwrite | readonly</li>
<li>setter相关修饰符：assign | retain | copy</li>
</ul>
</li>
<li><p>方法名修饰符：</p>
<p><code>getter=&lt;getMethodName&gt;,setter=&lt;setMethodName&gt;:指定该属性所使用的getter和setter方法的名称</code></p>
<p>一般用来修改BOOL类型的getter方法。</p>
</li>
<li><p>原子修饰符：</p>
<ul>
<li>atomic：原子属性(默认),为setter方法加锁，线程安全，但比较耗性能。</li>
<li>nonatomic：非原子属性,不为setter方法加锁，非线程安全,适合内存小的移动设备。</li>
</ul>
</li>
<li><p>读写性修饰符：</p>
<ul>
<li>readwrite：表明这个属性是可读可写的，系统为我们生成这个属性的setter和getter方法以及下划线开头的成员变量。</li>
<li>readonly：表明这个属性只能读不能写，系统只为我们生成一个getter方法及下划线开头的成员变量，不会创建setter方法。</li>
<li>注意：如果手动实现了setter和getter方法则不会再生成下划线开头的成员变量。</li>
</ul>
</li>
<li><p>setter相关修饰符：</p>
<ul>
<li><p>retain：针对对象类型进行内存管理(非ARC)。当给对象类型使用此修饰符时，setter方法会先将旧的对象属性release掉，再对新的对象进行一次赋值并进行一次retain操作。</p>
</li>
<li><p>assign：表示直接赋值， 基本数据类型、枚举、结构体(非OC对象) class类型。当一个对象被销毁时，指针不会被清空(所以修饰对象时容易造成坏内存 (非ARC下会用这个修饰对象)。</p>
</li>
<li><p>copy：以前主要用在NSString类型和Block，建立一个索引计数为1的对象，然后释放旧对象。</p>
</li>
<li><p>strong：除NSString\block以外(注意!这是以前的说法)的OC对象 , 强引用以保证属性作用域结束后不被销毁。</p>
</li>
<li><p>weak：当一个对象被销毁时，指针被清空。一般用在已经添加到父控件中的控件,因为父控件会对子控件进行引用,也就是retain,所以自己的作用域结束之后不会被释放</p>
</li>
<li><p>注意：</p>
<p>​    (1).系统默认属性是assign。retain是指针的复制，copy是内容的复制。</p>
<p>​    (2).用copy修饰字符串时：在setter方法中会判断 传入的字符串 是否是可变的  如果是可变的就分配新的内存再赋值  如果是不可变的就直接赋值地址  而实际上开发中其实大量使用的是不可变的字符串   所以最好使用 strong 修饰字符串,可以提升性能(减少一次判断)</p>
<p>​    (3).用copy修饰Block时:</p>
<p>​    非ARC环境下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;     block访问外部局部变量,block存放栈里面</div><div class="line">&gt;     只要block访问变量,而且是整个app都存在的变量,那么肯定在全局区</div><div class="line">&gt;     在非ARC中.不能使用retain引用block,因为不会放在堆里面,在非ARC中只能使用copy,才会把block放在堆里面</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<pre><code>​    ARC环境下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;     只要block访问了外部局部变量,block就会存放到堆里面</div><div class="line">&gt;     可以使用strong去引用  因为本身就已经是存放在堆区了</div><div class="line">&gt;     也可以用copy，但是用stong性能更好</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</code></pre></blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>总结(ARC环境)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;     用strong修饰OC对象以及NSString和Block , 没添加到父控件上的控件</div><div class="line">&gt;     用weak修饰已经被添加到父控件上的控件 以及 代理对象</div><div class="line">&gt;     用assign基本数据类型、枚举、结构体(非OC对象)   class类型</div><div class="line">&gt;     用copy修饰一种情况下的NSString--&gt;不确定赋值过程中用的是可变还是不可变字符串</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<pre><code>​
</code></pre></blockquote>
<h2 id="二十、iOS文件系统"><a href="#二十、iOS文件系统" class="headerlink" title="二十、iOS文件系统"></a>二十、iOS文件系统</h2><blockquote>
<ol>
<li><p>iOS程序为沙盒机制,APP只能访问自己目录下的文件,不能直接访问其他目录内容，每个APP默认都会创建以下目录结构Documents、Library、tmp。</p>
<ul>
<li>NSBundle：包含所有的资源文件和可执行文件，并且是只读文件目录。</li>
</ul>
</li>
</ol>
<ul>
<li>Documents：存放应用程序产生的数据，会被itunes备份同步；</li>
<li>Library：包含两个子目录：Caches 和 Preferences：<ul>
<li>Preferences：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好,会被itunes备份同步。</li>
<li>Caches：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息,不会被itunes备份同步。</li>
</ul>
</li>
<li><p>tmp：存放临时数据,当不在用时应该删除掉临时文件,系统也有可能在程序不运行时删除该文件夹下内容。</p>
<pre><code>&lt;img src=&quot;iOS学习笔记/file1.png&quot;  width=&quot;400&quot; height=300/&gt;
</code></pre></li>
</ul>
<ol>
<li><p>获取方式：</p>
<ul>
<li><p>NSBundle：<code>NSString *path = [[NSBundle mainBundle] pathForResource: ofType: ]];</code></p>
<p><code>注意：NSBundle中的文件只能进行读取不能进行更改，即使对NSBundle中的文件进行更改，其实是更改内存中其所对应的文件，实际的文件是没有被更改过的；</code></p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>Home目录：<code>NSHomeDirectory()</code></p>
</li>
<li><p>Documents目录：</p>
<ul>
<li><p>方式1: <code>NSHomeDirectory().stringByAppendingPathComponent(&quot;Documents&quot;)</code></p>
</li>
<li><p>方式2: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;      NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);</div><div class="line">&gt;      NSString *document_path = [paths objectAtIndex:0]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>Library目录：</p>
<ul>
<li><p>方式1: <code>NSHomeDirectory().stringByAppendingPathComponent(&quot;Library&quot;)</code></p>
</li>
<li><p>方式2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;      NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</div><div class="line">&gt;      NSString *libPath = [paths objectAtIndex:0];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>Caches目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;       NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);</div><div class="line">&gt;       NSString *libPath = [paths objectAtIndex:0]; </div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li>tmp目录：<code>NSTemporaryDirectory()</code></li>
</ul>
</blockquote>
<h2 id="二十一、iOS文件操作："><a href="#二十一、iOS文件操作：" class="headerlink" title="二十一、iOS文件操作："></a>二十一、iOS文件操作：</h2><blockquote>
<ol>
<li><p>获得NSFileManager：</p>
<p><code>NSFileManager *fileManager = [NSFileManager defaultManager];</code></p>
</li>
<li><p>判断文件夹/文件是否存在：</p>
<p><code>[fileManager fileExistsAtPath: ];</code></p>
</li>
<li><p>创建文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;    //参数createIntermediates为是否创建新建文件目录里不存在的中间目录，详见文档，根据error判断是否成功创建</div><div class="line">&gt;    [fileManager createDirectoryAtPath: withIntermediateDirectories: createIntermediates attributes: error: ]</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>创建文件的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;    //成功创建和文件已经存在都会返回YES，所以有时需要让程序更清晰，需要在创建文件前先判断文件是否已经存在，存在则不进行创建</div><div class="line">&gt;    [fileManager createFileAtPath: contents: attributes: ];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>删除文件或文件夹：</p>
<p><code>[fileManager removeItemAtPath:* *error: ];</code></p>
</li>
<li><p>注意：</p>
<ul>
<li>Path为文件夹/文件的路径全名</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="二十二、iOS归档："><a href="#二十二、iOS归档：" class="headerlink" title="二十二、iOS归档："></a>二十二、iOS归档：</h2><blockquote>
<ol>
<li><p>自定义归档对象需要实现NSCoding协议。</p>
</li>
<li><p>自定义归档对象重写(void)encodeWithCoder:(NSCoder *)aCoder方法指定将那些属性进行归档。</p>
<p>重写(instancetype)initWithCoder:(NSCoder *)coder指定如何读写归档的对象属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;    - (void)encodeWithCoder:(NSCoder *)aCoder&#123;</div><div class="line">&gt;        [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</div><div class="line">&gt;        [aCoder encodeInt:self.age forKey:@&quot;age&quot;];</div><div class="line">&gt;    &#125;</div><div class="line">&gt;    - (instancetype)initWithCoder:(NSCoder *)coder&#123;</div><div class="line">&gt;        if (self = [super init]) &#123;</div><div class="line">&gt;            self.name = [coder decodeObjectForKey:@&quot;name&quot;];</div><div class="line">&gt;            self.age = [coder decodeIntForKey:@&quot;age&quot;];</div><div class="line">&gt;        &#125;</div><div class="line">&gt;        return self;</div><div class="line">&gt;    &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>读写操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt;    // 写操作</div><div class="line">&gt;    Person *person = [[Person alloc] init];</div><div class="line">&gt;    person.name = @&quot;name&quot;;</div><div class="line">&gt;    person.age = 20;</div><div class="line">&gt;    NSString *savePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) objectAtIndex:0];</div><div class="line">&gt;    NSString *saveFile = [savePath stringByAppendingPathComponent:@&quot;person.data&quot;];</div><div class="line">&gt;    [NSKeyedArchiver archiveRootObject:person toFile:saveFile];</div><div class="line">&gt;    // 读操作    </div><div class="line">&gt;    person = [NSKeyedUnarchiver unarchiveObjectWithFile:saveFile];</div><div class="line">&gt;    NSLog(@&quot;%@&quot;, person);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h2 id="二十三、自定义UITableViewCell："><a href="#二十三、自定义UITableViewCell：" class="headerlink" title="二十三、自定义UITableViewCell："></a>二十三、自定义UITableViewCell：</h2><blockquote>
<p>自定义等高Cell：</p>
<ol>
<li><p>代码：</p>
<p>frame方式：</p>
<ul>
<li><p>第1步：在自定义的UITableViewCell类的<code>(instancetype)initWithStyle:(UITableViewCellStyle) reuseIdentifier:(NSString *)</code>方法中添加所有的子控件；</p>
</li>
<li><p>第2步：在<code>layoutSubviews</code>方法中设置所有子控件的frame(进行子控件的位置布局)；</p>
</li>
<li><p>第3步：添加一个数据模型属性，当有模型数据设置进来的时候，进行数据绑定。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;      - (void)setStatus:(StatusItem *)item&#123;</div><div class="line">&gt;      	self.iconImageView.image = [UIImage imageNamed:item.icon];</div><div class="line">&gt;      	self.titleLabel.text = item.title;</div><div class="line">&gt;      &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<pre><code>注意：在UITableViewController类中的`(UITableViewCell *)tableView:(UITableView *) cellForRowAtIndexPath:(NSIndexPath *)`设置模型数据，将数据和控件绑定。
</code></pre><p>   autolayout方式：</p>
<ul>
<li>使用Masonry在<code>initWithStyle</code>或<code>layoutSubviews</code>对相关的控件添加约束。</li>
</ul>
<ol>
<li><p>xib：</p>
<ul>
<li><p>第1步：创建xib文件，并和自定义的UITableViewCell类绑定，并设置复用的ID。(或者直接在viewDidLoad方法通过<code>[self.tableView registerNib:[UINib nibWithNibName:@&quot;StatusCell&quot; bundle:nil] forCellReuseIdentifier:ID1]</code>方式进行利用优化)</p>
<p><img src="/2017/01/31/iOS学习笔记/cell1.png" width="600" height="300/"></p>
</li>
<li><p>第2步：在自定义的UITableViewCell中设置模型数据时进行数据绑定。</p>
</li>
<li><p>第3步：在UITableViewController的(UITableViewCell <em>)tableView:(UITableView </em>) cellForRowAtIndexPath:(NSIndexPath *)方法中从xib创建自定义的UITableViewCell。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;      static NSString *ID = @&quot;ID&quot;;</div><div class="line">&gt;      StatusTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];</div><div class="line">&gt;      if (cell == nil) &#123;</div><div class="line">&gt;          cell = [[[NSBundle mainBundle] loadNibNamed:@&quot;StatusCell&quot; owner:nil options:nil] lastObject];</div><div class="line">&gt;      &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>storyboard：</p>
<ul>
<li>第1步：在StoryBoard中添加UITableViewController，并在其上设置UITableViewCell的相应控件。</li>
<li>第2步：在StoryBoard中设置UITableViewCell的复用ID。</li>
<li>第3步：在自定义的UITableViewCell类中提供数据模型属性，并在设置方法中将模型和控件进行绑定。</li>
<li>第4步：在UITableViewController中使用传统方式或者注册类方式进行复用优化。</li>
</ul>
</li>
</ol>
<p>自定义不等高Cell：</p>
<ol>
<li><p>代码：</p>
<p>frame方式：</p>
<p>​    主要步骤和等高Cell的计算方式一样，主要是在计算一些具有动态宽高的控件时需要注意，同时在UITableViewController的<code>(CGFloat)tableView:(UITableView *) heightForRowAtIndexPath:(NSIndexPath *)</code>中计算根据每行的不同的数据模型计算cell的高度。</p>
<p>​    例如：计算宽度为距离屏幕左右各10,高度不固定的UILabel的高度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;    NSDictionary *contentArrt = @&#123;NSFontAttributeName: [UIFont systemFontOfSize:14]&#125;;</div><div class="line">&gt;    CGSize textSize = CGSizeMake([UIScreen mainScreen].bounds.size.width-2*space, MAXFLOAT);</div><div class="line">&gt;    CGFloat contentHeight = [item.text boundingRectWithSize:textSize options:NSStringDrawingUsesLineFragmentOrigin attributes:contentArrt context:nil].size.height;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>   ​    计算某个使用某字体的单行的UILable的宽高：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;    NSDictionary *nickAtt = @&#123;NSFontAttributeName : [UIFont systemFontOfSize:14]&#125;;</div><div class="line">&gt;    CGSize nickSize = [self.item.name sizeWithAttributes:nickAtt];</div><div class="line">&gt;    CGFloat nickW = nickSize.width;</div><div class="line">&gt;    CGFloat nickH = nickSize.height;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>   autolayout方式：</p>
<ol>
<li><p>xib：</p>
</li>
<li><p>storyboard：</p>
<ul>
<li><p>在storyboard设置好UITableViewCell的各控件的约束后，需要在UITableViewController中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;      self-sizing(iOS8以后)</div><div class="line">&gt;      // 设置tableview的cell高度是自动计算的。</div><div class="line">&gt;      self.tableView.rowHeight = UITableViewAutomaticDimension;</div><div class="line">&gt;      // 设置估算高度</div><div class="line">&gt;      self.tableView.estimatedRowHeight = 44;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="二十四、代理的使用步骤："><a href="#二十四、代理的使用步骤：" class="headerlink" title="二十四、代理的使用步骤："></a>二十四、代理的使用步骤：</h2><blockquote>
<ol>
<li><p>代理的定义：</p>
<ul>
<li><p>协议名字的格式一般是：类名 + Delegate，例：UITableViewDelegate</p>
</li>
<li><p>设计细节：</p>
<p>​    (1).一般都是@optional(让代理可以有选择性去实现一些代理方法)</p>
<p>​    (2).方法名一般都以类名开头，例：<code>- (void)scrollViewDidScroll:</code></p>
<p>​    (3).一般都需要将对象本身传出去，例：tableView的代理方法都会把tableView本身传出去</p>
</li>
<li><p>必须要遵守NSObject协议(基协议)，例：<code>@protocol MyCellDelegate &lt;NSObject&gt;</code></p>
</li>
</ul>
</li>
<li><p>代理的声明：</p>
<ul>
<li><p>代理的类型格式：id&lt;协议&gt; delegate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      @property (nonatomic, weak) id&lt;XMGWineCellDelegate&gt; delegate;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>设置代理对象：</p>
</li>
<li><p>代理对象遵守协议，并实现协议里的方法：</p>
</li>
<li><p>代理方法的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;    // 如果代理方法是@optional，那么需要判断方法是否有实现,直接调用可能会报错</div><div class="line">&gt;    if ([self.delegate respondsToSelector:@selector(wineCellDidClickPlusButton:)]) &#123;</div><div class="line">&gt;        [self.delegate wineCellDidClickPlusButton:self];</div><div class="line">&gt;    &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>   ​</p>
</blockquote>
<h2 id="二十五、iOS监听事件的方法比较"><a href="#二十五、iOS监听事件的方法比较" class="headerlink" title="二十五、iOS监听事件的方法比较"></a>二十五、iOS监听事件的方法比较</h2><blockquote>
<ol>
<li>通知（NSNotificationCenter\NSNotification）<ul>
<li>任何对象之间都可以传递消息</li>
<li>使用范围<ul>
<li>1个对象可以发通知给多个对象</li>
<li>1个对象可以接受多个对象发出的通知</li>
</ul>
</li>
<li>要求:必须得保证通知的名字在发出和监听时是一致的</li>
</ul>
</li>
<li>KVO<ul>
<li>仅仅是能监听对象属性的改变（灵活度不如通知和代理）</li>
</ul>
</li>
<li>代理<ul>
<li>使用范围<ul>
<li>1个对象只能设置一个代理(假设这个对象只有1个代理属性)</li>
<li>1个对象能成为多个对象的代理</li>
</ul>
</li>
</ul>
</li>
<li>如何选择?<ul>
<li><code>代理</code>比<code>通知</code>规范</li>
<li>建议使用<code>代理</code>多于<code>通知</code>,能使用代理尽量使用代理</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="二十六、UIView形变"><a href="#二十六、UIView形变" class="headerlink" title="二十六、UIView形变:"></a>二十六、UIView形变:</h2><blockquote>
<ol>
<li><p>位移形变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;    [UIView animateWithDuration:0.5 animations:^&#123;</div><div class="line">&gt;    // 将当前的动画x和y属性进行修改移动，可多次移动</div><div class="line">&gt;    //  self.transView.transform = CGAffineTransformTranslate(self.transView.transform, 100, 100);</div><div class="line">&gt;      	// 将原有的动画的x和y属性进行修改移动，只能移动一次</div><div class="line">&gt;        self.transView.transform = CGAffineTransformMakeTranslation(100, 100);</div><div class="line">&gt;    &#125;];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>旋转形变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;    [UIView animateWithDuration:0.5 animations:^&#123;</div><div class="line">&gt;    //   self.transView.transform = CGAffineTransformRotate(self.transView.transform, M_PI_4);</div><div class="line">&gt;         self.transView.transform = CGAffineTransformMakeRotation(M_PI_4);</div><div class="line">&gt;    &#125;];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>缩放形变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;    [UIView animateWithDuration:0.5 animations:^&#123;</div><div class="line">&gt;    //   self.transView.transform = CGAffineTransformScale(self.transView.transform, 0.5, 0.5);</div><div class="line">&gt;         self.transView.transform = CGAffineTransformMakeScale(0.5, 0.5);</div><div class="line">&gt;    &#125;];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>透明度形变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;    [UIView animateWithDuration:0.5 animations:^&#123;</div><div class="line">&gt;       self.transView.alpha = 0.5;</div><div class="line">&gt;    &#125;];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h2 id="二十七：hitTest与pointInside方法："><a href="#二十七：hitTest与pointInside方法：" class="headerlink" title="二十七：hitTest与pointInside方法："></a>二十七：hitTest与pointInside方法：</h2><blockquote>
<ol>
<li>hitTest方法：-(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event<ul>
<li>作用：寻找响应点击事件最合适的view</li>
<li>参数：当前手指所在的点，产生的事件</li>
<li>返回值：最合适的view，如果当前view不是最合适的view，则返回nil</li>
<li>调用时机：当事件传递给当前控件时就会调用这个控件的hitTest方法</li>
</ul>
</li>
<li>pointInside方法：-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event<ul>
<li>作用：判断事件point在不在方法调用View上</li>
<li>参数：当前手指所在的点，产生的事件</li>
<li>返回值：是否在调用View上</li>
<li>调用时机：hitTest底层会调用用这个方法</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="二十八、事件传递过程："><a href="#二十八、事件传递过程：" class="headerlink" title="二十八、事件传递过程："></a>二十八、事件传递过程：</h2><blockquote>
<ol>
<li><p>事件传递完整过程：</p>
<p>在产生一个事件时,系统会将该事件加入到一个由UIApplication管理的事件队列中,<br>UIApplication会从事件队列中取出最前面的事件,将它传递给先发送事件给应用程序的主窗口.<br>主窗口会调用hitTest方法寻找最适合的视图控件,找到后就会调用视图控件的touches方法来做具体的事情.<br>当调用touches方法,它的默认做法, 就会将事件顺着响应者链条往上传递，<br>传递给上一个响应者,接着就会调用上一个响应者的touches方法</p>
</li>
<li><p>如何寻找上一个响应者：</p>
<ul>
<li>如果当前的View是控制器的View,那么控制器就是上一个响应者.</li>
<li>如果当前的View不是控制器的View,那么它的父控件就是上一个响应者.</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理.</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象.</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃.</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="二十九、Quartz2D："><a href="#二十九、Quartz2D：" class="headerlink" title="二十九、Quartz2D："></a>二十九、Quartz2D：</h2><blockquote>
<ol>
<li><p>Quartz2D是一个二维的绘图引擎,同时支持iOS和Mac系统，可以画基本线条,绘制文字,图片,截图,自定义UIView。</p>
</li>
<li><p>图形上下文：</p>
<ul>
<li>图形上下文是用来保存用户绘制的内容状态,并决定绘制到哪个地方的.用户把绘制好的内容先保存到图形上下文,然后根据选择的图形上下文的不同,绘制的内容显示到地方也不相同,即输出目标也不相同.</li>
</ul>
</li>
<li><p>分类：</p>
<ul>
<li>Bitmap Graphics Context(位图上下文)</li>
<li>PDF Graphics Context</li>
<li>Window Graphics Context </li>
<li>Layer Graphics Context(图层上下文,自定义UIView取得上下文就是图层上下文.UIView之所以能够显示就是因为他内部有一个图层)</li>
<li>Printer Graphics Context</li>
</ul>
</li>
<li><p>自定义UIView的步骤：</p>
<ul>
<li><p>首先得要有上下文,有了上下文才能决定把绘制的东西显示到哪个地方去.其次就是这个上下文必须得和View相关联.才能将内容绘制到View上面.</p>
</li>
<li><p>具体步骤：</p>
<p>​    1.要先自定定UIView<br>​    2.实现DrawRect方法<br>​    3.在DrawRect方法中取得跟View相关联的上下文.<br>​    4.绘制路径(描述路径长什么样).<br>​    5.把描述好的路径保存到上下文(即:添加路径到上下文)<br>​    6.把上下文的内容渲染到View</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="三十、CALayer："><a href="#三十、CALayer：" class="headerlink" title="三十、CALayer："></a>三十、CALayer：</h2><blockquote>
<ol>
<li><p>CALayer和UIView的区别：</p>
<ul>
<li>CALayer和UIView都能实现相同的显示效果。</li>
<li>对比CALayer，UIView多了一个事件处理的功能。CALayer不能处理用户的触摸事件，而UIView可以。</li>
<li>所以，如果显示出来的东西需要跟用户进行交互的话，用UIView；如果不需要跟用户进行交互，用UIView或者CALayer都可以。</li>
<li>当然，CALayer的性能会高一些，因为它少了事件处理的功能，更加轻量级。</li>
</ul>
</li>
<li><p>position和anchorPoint：</p>
<p>position：</p>
<ul>
<li>用来设置CALayer在父层中的位置</li>
<li>以父层的左上角为原点(0, 0)</li>
</ul>
<p>anchorPoint：</p>
<ul>
<li>称为“定位点”、“锚点”</li>
<li><code>决定着CALayer身上的哪个点会是position属性所指的位置</code></li>
<li>以自己的左上角为原点(0, 0)</li>
<li>它的x、y取值范围都是0~1，默认值为（0.5, 0.5）</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="三十一、frame、bounds和center："><a href="#三十一、frame、bounds和center：" class="headerlink" title="三十一、frame、bounds和center："></a>三十一、frame、bounds和center：</h2><blockquote>
<p><img src="/2017/01/31/iOS学习笔记/31.png" width="600" height="300/"></p>
<ul>
<li><p>origin：起点位置</p>
</li>
<li><p>frame：该view在父view坐标系统中的位置和大小。（参照点是父坐标系统）</p>
</li>
<li><p>bounds：该view在本地坐标系统中的位置和大小。（参照点是本地坐标系统，就相当于ViewB自己的坐标系统，以0,0点为起点）</p>
</li>
<li><p>center：该view的中心点在父view坐标系统中的位置。（参照点是父坐标系统）</p>
<p>参考：<a href="http://blog.csdn.net/pucker/article/details/7634479" target="_blank" rel="external">http://blog.csdn.net/pucker/article/details/7634479</a></p>
<p>​        <a href="http://blog.csdn.net/mad1989/article/details/8711697" target="_blank" rel="external">http://blog.csdn.net/mad1989/article/details/8711697</a></p>
</li>
</ul>
</blockquote>
<h2 id="三十二、Core-Animation："><a href="#三十二、Core-Animation：" class="headerlink" title="三十二、Core Animation："></a>三十二、Core Animation：</h2><blockquote>
<ol>
<li><p>Core Animation的动画执行过程都是在后台操作的，不会阻塞主线程。</p>
</li>
<li><p>Core Animation是直接作用在CALayer上的，并非UIView。</p>
</li>
<li><p>核心动画继承结构：</p>
<p><img src="/2017/01/31/iOS学习笔记/32.png" width="600" height="300/"></p>
</li>
<li><p>CABasicAnimation示例：</p>
<ul>
<li>单独动画：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;    CABasicAnimation *anim = [CABasicAnimation animation];</div><div class="line">&gt;    anim.keyPath = @&quot;position.y&quot;;</div><div class="line">&gt;    anim.toValue = @400;</div><div class="line">&gt;    // 以下两行设置动画不回复原始状态</div><div class="line">&gt;    anim.removedOnCompletion = NO;</div><div class="line">&gt;    anim.fillMode = kCAFillModeForwards;  </div><div class="line">&gt;    [self.redView.layer addAnimation:anim forKey:nil];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>   ​</p>
<ul>
<li><p>组动画：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt;    CABasicAnimation *anim = [CABasicAnimation animation];</div><div class="line">&gt;    anim.keyPath = @&quot;position.y&quot;;</div><div class="line">&gt;    anim.toValue = @400;</div><div class="line">&gt;    CABasicAnimation *anim2 = [CABasicAnimation animation];</div><div class="line">&gt;    anim2.keyPath = @&quot;transform.scale&quot;;</div><div class="line">&gt;    anim2.toValue = @0.5;</div><div class="line">&gt;    CAAnimationGroup *group = [CAAnimationGroup animation];</div><div class="line">&gt;    //会自动执行animations数组当中所有的动画对象</div><div class="line">&gt;    group.animations = @[anim,anim2];   </div><div class="line">&gt;    group.removedOnCompletion = NO;</div><div class="line">&gt;    group.fillMode = kCAFillModeForwards;</div><div class="line">&gt;    [self.redView.layer addAnimation:group forKey:nil];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>转场动画：CATransition</p>
<ul>
<li><p>动画属性：</p>
<p>​    type：动画过渡类型</p>
<p>​    subtype：动画过渡方向</p>
<p>​    startProgress：动画起点(在整体动画的百分比)</p>
<p>​    endProgress：动画终点(在整体动画的百分比)</p>
</li>
<li><p>转场动画过渡效果：</p>
<p><img src="/2017/01/31/iOS学习笔记/32_1.png" width="600" height="300/"></p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="三十三、UIAppearance"><a href="#三十三、UIAppearance" class="headerlink" title="三十三、UIAppearance"></a>三十三、UIAppearance</h2><blockquote>
<ul>
<li><p>UIAppearance是一个协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;   @protocol UIAppearance &lt;NSObject&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>UIView默认已经遵守了这个协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;   @interface UIView : UIResponder &lt;NSCoding, UIAppearance, UIAppearanceContainer, UIDynamicItem, UITraitEnvironment, UICoordinateSpace, UIFocusEnvironment&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>UIAppearance都有什么方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;   + (instancetype)appearance;</div><div class="line">&gt;   + (instancetype)appearanceWhenContainedIn:(nullable Class &lt;UIAppearanceContainer&gt;)ContainerClass, ... NS_REQUIRES_NIL_TERMINATION NS_DEPRECATED_IOS(5_0, 9_0, &quot;Use +appearanceWhenContainedInInstancesOfClasses: instead&quot;) __TVOS_PROHIBITED;</div><div class="line">&gt;   + (instancetype)appearanceWhenContainedInInstancesOfClasses:(NSArray&lt;Class &lt;UIAppearanceContainer&gt;&gt; *)containerTypes NS_AVAILABLE_IOS(9_0);</div><div class="line">&gt;   + (instancetype)appearanceForTraitCollection:(UITraitCollection *)trait NS_AVAILABLE_IOS(8_0);</div><div class="line">&gt;   + (instancetype)appearanceForTraitCollection:(UITraitCollection *)trait whenContainedIn:(nullable Class &lt;UIAppearanceContainer&gt;)ContainerClass, ... NS_REQUIRES_NIL_TERMINATION NS_DEPRECATED_IOS(8_0, 9_0, &quot;Use +appearanceForTraitCollection:whenContainedInInstancesOfClasses: instead&quot;) __TVOS_PROHIBITED;</div><div class="line">&gt;   + (instancetype)appearanceForTraitCollection:(UITraitCollection *)trait whenContainedInInstancesOfClasses:(NSArray&lt;Class &lt;UIAppearanceContainer&gt;&gt; *)containerTypes  NS_AVAILABLE_IOS(9_0);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>让某一类控件同时表现某种属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;   [[UIButton appearance] setBackgroundColor:[UIColor blackColor]];</div><div class="line">&gt;   [[UIButton appearance] setTitle:@&quot;呵呵哒&quot; forState:UIControlStateNormal];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>让某一类控件在另一种控件中同时变现某种属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;   // 使UIView上面的UIButton的titleColor都变成灰色的效果</div><div class="line">&gt;   [[UIButton appearanceWhenContainedInInstancesOfClasses:@[[UIView class]]] setTitleColor:[UIColor grayColor] forState:UIControlStateNormal];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h2 id="三十四、layoutSubviews的调用时机："><a href="#三十四、layoutSubviews的调用时机：" class="headerlink" title="三十四、layoutSubviews的调用时机："></a>三十四、layoutSubviews的调用时机：</h2><blockquote>
<ul>
<li>1.直接调用[self setNeedsLayout];</li>
<li>2.addSubview的时候。</li>
<li>3.当view的size发生改变的时候。</li>
<li>4.滑动UIScrollView的时候。</li>
<li>5.旋转Screen会触发父UIView上的layoutSubviews事件。</li>
</ul>
<p><strong>注意：当view的size的值为0的时候，addSubview也不会调用自定义view的layoutSubviews。当要给这个自定义view添加子控件的时候不管他的size有没有值都会调用</strong>。</p>
</blockquote>
<h2 id="三十五、Block详解："><a href="#三十五、Block详解：" class="headerlink" title="三十五、Block详解："></a>三十五、Block详解：</h2><blockquote>
<ol>
<li><p>定义方式：</p>
<ul>
<li><p>本地变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      @property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>方法定义形参：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      - (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>方法调用实参：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;      [someObject someMethodThatTakesABlock:^returnType (parameters) &#123;...&#125;];</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li><p>别名(<strong>typedef</strong>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;      typedef returnType (^TypeName)(parameterTypes);</div><div class="line">&gt;      TypeName blockName = ^returnType(parameters) &#123;...&#125;;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>&gt;</p>
<blockquote>
<ol>
<li><p>注意事项：</p>
<ul>
<li>对于希望在block中修改的外界局部对象，我们可以给这些变量加上__block关键字修饰，这样就能在block中修改这些变量。</li>
<li>block在捕获变量的时候只会保存变量被捕获时的状态（对象变量除外），之后即便变量再次改变，block中的值也不会发生改变。</li>
<li>系统提供给我们__weak的关键字用来修饰对象变量，声明这是一个弱引用的对象，从而解决了循环引用的问题。</li>
<li>​</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="附录一：常用第三方框架"><a href="#附录一：常用第三方框架" class="headerlink" title="附录一：常用第三方框架"></a>附录一：常用第三方框架</h2><ol>
<li><a href="https://github.com/SnapKit/Masonry/" title="github" target="_blank" rel="external">Masonry</a>：是iOS控件布局中经常使用的一个轻量级AutoLayout框架。</li>
<li><a href="https://github.com/jdg/MBProgressHUD/ github" target="_blank" rel="external">MBProgressHUD</a>：是一个半透明的加载显示界面。</li>
<li><a href="https://github.com/CoderMJLee/MJExtension/ github" target="_blank" rel="external">MJExtension</a>：是一个字典转模型框架。</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/小知识点/" rel="tag"># 小知识点</a>
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/25/iOS之UI总结/" rel="next" title="iOS之UI总结">
                <i class="fa fa-chevron-left"></i> iOS之UI总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/17/SpringMVC学习笔记/" rel="prev" title="SpringMVC学习笔记">
                SpringMVC学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/01/31/iOS学习笔记/"
           data-title="iOS学习笔记" data-url="https://qjbagugit.github.io/2017/01/31/iOS学习笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Timer" />
          <p class="site-author-name" itemprop="name">Timer</p>
          <p class="site-description motion-element" itemprop="description">路漫漫其修远兮，吾将上下而求索</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              原博客
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://blog.csdn.net/qjbagu/" title="CSDN博客" target="_blank">CSDN博客</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、加载图片的方式："><span class="nav-number">1.</span> <span class="nav-text">一、加载图片的方式：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、pch文件："><span class="nav-number">2.</span> <span class="nav-text">二、pch文件：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、info-plist文件："><span class="nav-number">3.</span> <span class="nav-text">三、info.plist文件：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、从代码加载指定的storyboard文件："><span class="nav-number">4.</span> <span class="nav-text">四、从代码加载指定的storyboard文件：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、ViewController中loadView方法："><span class="nav-number">5.</span> <span class="nav-text">五、ViewController中loadView方法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、背景图片的拉伸："><span class="nav-number">6.</span> <span class="nav-text">六、背景图片的拉伸：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、KVC：key-value-coding-键值编码"><span class="nav-number">7.</span> <span class="nav-text">七、KVC：key value coding(键值编码)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、KVO：key-value-observing-键值监听"><span class="nav-number">8.</span> <span class="nav-text">八、KVO：key value observing(键值监听)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、适配"><span class="nav-number">9.</span> <span class="nav-text">九、适配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、UITableView"><span class="nav-number">10.</span> <span class="nav-text">十、UITableView</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一、UIApplication"><span class="nav-number">11.</span> <span class="nav-text">十一、UIApplication</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十二、UIWindow"><span class="nav-number">12.</span> <span class="nav-text">十二、UIWindow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十三、多控制器：UINavigationController"><span class="nav-number">13.</span> <span class="nav-text">十三、多控制器：UINavigationController</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十四、控制器生命周期："><span class="nav-number">14.</span> <span class="nav-text">十四、控制器生命周期：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十五、OC中BOOL和bool的区别："><span class="nav-number">15.</span> <span class="nav-text">十五、OC中BOOL和bool的区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十六、initialize和load方法的区别："><span class="nav-number">16.</span> <span class="nav-text">十六、initialize和load方法的区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十七、instancetype和id的区别："><span class="nav-number">17.</span> <span class="nav-text">十七、instancetype和id的区别：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十八、OC访问修饰符："><span class="nav-number">18.</span> <span class="nav-text">十八、OC访问修饰符：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十九、OC属性修饰符："><span class="nav-number">19.</span> <span class="nav-text">十九、OC属性修饰符：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十、iOS文件系统"><span class="nav-number">20.</span> <span class="nav-text">二十、iOS文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十一、iOS文件操作："><span class="nav-number">21.</span> <span class="nav-text">二十一、iOS文件操作：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十二、iOS归档："><span class="nav-number">22.</span> <span class="nav-text">二十二、iOS归档：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十三、自定义UITableViewCell："><span class="nav-number">23.</span> <span class="nav-text">二十三、自定义UITableViewCell：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十四、代理的使用步骤："><span class="nav-number">24.</span> <span class="nav-text">二十四、代理的使用步骤：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十五、iOS监听事件的方法比较"><span class="nav-number">25.</span> <span class="nav-text">二十五、iOS监听事件的方法比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十六、UIView形变"><span class="nav-number">26.</span> <span class="nav-text">二十六、UIView形变:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十七：hitTest与pointInside方法："><span class="nav-number">27.</span> <span class="nav-text">二十七：hitTest与pointInside方法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十八、事件传递过程："><span class="nav-number">28.</span> <span class="nav-text">二十八、事件传递过程：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二十九、Quartz2D："><span class="nav-number">29.</span> <span class="nav-text">二十九、Quartz2D：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三十、CALayer："><span class="nav-number">30.</span> <span class="nav-text">三十、CALayer：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三十一、frame、bounds和center："><span class="nav-number">31.</span> <span class="nav-text">三十一、frame、bounds和center：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三十二、Core-Animation："><span class="nav-number">32.</span> <span class="nav-text">三十二、Core Animation：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三十三、UIAppearance"><span class="nav-number">33.</span> <span class="nav-text">三十三、UIAppearance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三十四、layoutSubviews的调用时机："><span class="nav-number">34.</span> <span class="nav-text">三十四、layoutSubviews的调用时机：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三十五、Block详解："><span class="nav-number">35.</span> <span class="nav-text">三十五、Block详解：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录一：常用第三方框架"><span class="nav-number">36.</span> <span class="nav-text">附录一：常用第三方框架</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Timer</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"Timer的博客"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js?v=5.1.0"></script>
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
